# How to Use the AO Shared Service Library

This page is meant to be an overview of functionality, for complete documentation see the [full API documentation generated by Doxygen] (https://github.com/AO-StreetArt/AOSharedServiceLibrary/tree/master/docs/html).

## Core Components

### Service Component Factories

The Service Component Factories are components which allow us to build instances of the interfaces exposed by the library.

It's important that we use the factory to get instances of the interfaces as the interfaces guarantee backwards-compatibility.  While particular implementations may change,
the interfaces will remain the same across versions of the library.  For example:

    #include "include/factory_cli.h"
    #include "include/factory/commandline_interface.h"

    // Set up a Service Component Factory, where we get our application components
    CommandLineInterpreterFactory cli_factory;

The factory then provides us access to instances of the interfaces exposed by the library.  Let's take a look with the components below.

Note: Be sure to delete anything you build with the factories!

### Callbacks

Request-based callbacks are critical components of AOSSL, and can be seen used with several AOSSL components.  All callbacks match the following method signature:
    std::string process_request(struct Request *req)

The Request object has a few properties which are relevent:

* req_data - Used to store original request data
* req_addr - Used to store the request type
* req_err - A pointer used to store any error messages from the request
* resp_data - Used to store response data from the request

The Request Error, if present, will come in the form of:

    //! A struct that gets passed to callbacks to transmit errors
    struct RequestError
    {
      //! A numerical error code
      int err_code;

      //! An Error message
      std::string err_message;
      RequestError() {err_code = NOERROR; err_message = "";}
    };

## Choose a Framework

### HTTP Server

The HTTP Server provides the architecture to expose a RESTful API for communication with your microservice.
This is the most common framework used for services in other languages.

The HTTP Server binds callbacks to URL's and allows for distinguishing between types of requests.

    #include "aossl/factory_http_server.h"
    #include "aossl/factory/http_server_interface.h"

    //Set up the HTTP Server
    HttpServerFactory http_server_factory;
    HttpServerInterface *http = http_server_factory.get_http_server_interface("0.0.0.0", 12345);

    //Bind some callbacks
    http->bind_callback("/", process_request);
    http->bind_callback("/test", process_test_request);

    //Bind a default callback, which is called when a
    //bound callback is not found for the request URL
    //Useful for API's that rely on dynamic URL construction for querying
    http->bind_default_callback(process_default_request);

Here, we bind the specified URL and port to a particular callback function, process_request().
Note that a string is returned from the method with the value being sent back to the client

    std::string process_request(struct Request *req)
    {
      std::string resp = "";
      if (req->req_err->err_code == NOERROR)
      {
        if (req->req_type == HTTP_GET)
        {
          resp = "Get Request";
          std::cout << resp << std::endl;
        }
        else if (req->req_type == HTTP_PUT)
        {
          resp = "Put Request";
          std::cout << resp << std::endl;
        }
        else if (req->req_type == HTTP_POST)
        {
          resp = "Post Request";
          std::cout << resp << std::endl;
          std::cout << req->req_data << std::endl;
        }
        else if (req->req_type == HTTP_DELETE)
        {
          resp = "Delete Request";
          std::cout << resp << std::endl;
        }
        else
        {
          resp = "Unknown Request Type";
          std::cout << resp << req->req_type << std::endl;
        }
      }
      return resp;
    }

And we distinguish between the types via the req_type pointer, as above.

We can also bind a default callback, which get's called whenever a bound URI is not found.
This can be particular useful for allowing access to things like key-value stores

### ZeroMQ Sockets

ZeroMQ is a permanent-connection alternative that provides high-speed, distributed messaging.

This provides Request/Reply Managers for both Inbound and Outbound sockets.

The Zmqio object exposes these methods:

* recv() - a blocking call to wait for a message
* send(const char * msg, int msg_size)
* send(std::string msg)

In order to connect to a socket, we ask the factory to create one:

    #include "aossl/factory/zmq_interface.h"
    #include "aossl/factory_zmq.h"

    ZmqComponentFactory zmq_factory;

    //Set up the outbound ZMQ Client
    Zmqio *zmqo = zmq_factory.get_zmq_outbound_interface("tcp://localhost:5555");

    //Set up the inbound ZMQ Client
    Zmqio *zmqi = zmq_factory.get_zmq_inbound_interface("tcp://*:5555");

## Tools

### Couchbase Administrator

Couchbase is a document-based database that allows for persistent, clusterable storage of data objects
for services.

The Couchbase Administrator works with objects that extend the interface 'writeable.h', found in the include directory.

`class TestData: public Writeable`

We start by defining a class which extends the Writeable interface.  This requires only that we have three
methods implemented:

* get_key
* set_key
* to_json

Now, we can start building objects in our DB:

    #include "include/factory_couchbase.h"
    #include "include/factory/couchbase_interface.h"

    CouchbaseComponentFactory couchbase_factory;

    //Create an object
    std::string name = "TestObject";
    TestData data ();
    data.set_key(name);
    const char* obj_key = data.get_key().c_str();

    //Build the Couchbase Admin (which will automatically connect to the DB),
    //by asking the factory to create the new instance
    CouchbaseInterface *cb = couchbase_factory.get_couchbase_interface("couchbase://localhost/default");

    //Bind callbacks
    cb->bind_get_callback(my_retrieval_callback);
    cb->bind_storage_callback(my_storage_callback);
    cb->bind_delete_callback(my_delete_callback);

Please note that couchbase binds to callbacks for all operations.  Here we see a simple example of the request callbacks:

    std::string my_storage_callback (Request *r)
    {
      if (r->req_err->err_code == NOERROR)
      {
        std::cout << "stored: " << r->req_addr << std::endl;
      }
      else
      {
        std::cout << "Failed to Store: " << r->req_addr << std::endl;
        std::cout << r->req_err->err_message << std::endl;
      }
      return r->req_addr;
    }

    std::string my_retrieval_callback (Request *r)
    {
      if (r->req_err->err_code == NOERROR)
      {
        std::cout << "retrieved: " << r->req_addr << std::endl;
        std::cout << "value: " << r->req_data << std::endl;
      }
      else
      {
        std::cout << "Failed to Store: " << r->req_addr << std::endl;
        std::cout << r->req_err->err_message << std::endl;
      }
      return r->req_addr;
    }

    std::string my_delete_callback (Request *r)
    {
      if (r->req_err->err_code == NOERROR)
      {
        std::cout << "removed: " << r->req_addr << std::endl;
      }
      else
      {
        std::cout << "Failed to Delete: " << r->req_addr << std::endl;
        std::cout << r->req_err->err_message << std::endl;
      }
      return r->req_addr;
    }


Once our callbacks are bound, we can start operating with Couchbase:

    //Write the object to the DB
    cb->create_object ( obj_ptr );
    cb->wait();
    //Get the object from the DB
    cb->load_object ( obj_key );
    cb->wait();
    //Update the object in the DB
    data.set_i ( 10 );
    cb->save_object ( obj_ptr );
    cb->wait();
    //Get the object from the DB to ensure it updates correctly
    cb->load_object ( obj_key );
    cb->wait();
    //Delete the object
    cb->delete_object ( obj_key );
    cb->wait();


### Redis Administrator

Redis is a key-value store that acts as an application cache

The Redis Admin allows for quick Redis access, and exposes the below methods to do so:

* std::string load ( const char * key )
* bool save ( const char * key, std::string msg )
* bool exists ( const char * key )
* bool del ( const char * key )
* bool expire ( const char * key, unsigned int second)

    #include "include/factory_redis.h"
    #include "include/factory/redis_interface.h"

    RedisComponentFactory redis_factory;
    RedisInterface *redis = redis_factory.get_redis_interface( "127.0.0.1", 6379 );

    //Now, we can access our basic Redis Operations
    bool bRet = redis->save("Test", "123");
    bool eRet = redis->exists("Test");
    std::string strValue = redis->load("Test");
    redis->del("Test");

### Consul Administrator

Consul is responsible for Service Registration & Discovery, Key-Value
Retrieval, and Health Check Configuration.

We start by importing the necessary interfaces and the establish the service factory

    #include "include/factory/consul_interface.h"
    #include "include/factory_consul.h"

    ConsulComponentFactory consul_factory;

Next, we define a Service which represents the current instance of the code.

This contains an ID, a name, a connection, and a port number.  Tags can be added or not:

    ServiceInterface *s = consul_factory.get_service_interface("1", "test", "http://localhost/", "5555");
    s->add_tag("Testing");

And build our Consul Admin, specifying the connection address:

    ConsulInterface *ca = consul_factory.get_consul_interface("localhost:8500");

Now, we can register the currently running instance of a service with Consul

    ca->register_service(*s);

And, we can unregister on shutdown:

    ca->deregister_service(*s);

We can get and set key-value storage elements:

    bool success = ca->set_config_value("Test", "123");
    assert(success);

    std::string test_val = ca->get_config_value("Test");
    logging->debug(test_val);

It also has some limited query capabilities, please see API for further details.

### HTTP Administrator

The HTTP Admin allows quick and easy HTTP Requests by exposing:

* bool put(std::string url, std::string data, int timeout)
* std::string get(std::string url, int timeout)
* bool post(std::string url, std::string data, int timeout)
* bool del(std::string url, int timeout)

    #include "include/factory_http_client.h"
    #include "include/factory/http_interface.h"

    HttpClientFactory http_client_factory;

    //Declare the admin
    HttpInterface *ha = http_client_factory.get_http_interface();

    //-------------------------------GET--------------------------------------//

    //Send the request
    std::string returned_string = ha->get(GETURL, 5);

    //-------------------------------PUT--------------------------------------//
    success = ha->put(PUTURL, "123", 5);

    //-------------------------------POST-------------------------------------//
    success = ha->post(POSTURL, "CLYMAN", 5);

    //------------------------------DELETE------------------------------------//
    success = ha->del(DELETEURL, 5);

### Logging
Logging exposes a pointer to a Logger instance, which can log directly itself or
provide categories to log to.

    #include "include/factory_logging.h"
    #include "include/factory/logging_interface.h"

    LoggingComponentFactory logging_factory;

    std::string initFileName = "configuration_file";
    logging = logging_factory.get_logging_interface(initFileName);

    logging->debug("My message");

We read from the [log4cpp configuration files] (http://log4cpp.sourceforge.net/api/classlog4cpp_1_1PropertyConfigurator.html), of which several examples are provided within the library itself.

### UUID Generation

Easy and quick Universally Unique ID Generation:

    #include "include/factory_uuid.h"
    #include "include/factory/uuid_interface.h"

    uuidComponentFactory uuid_factory;
    uuidInterface *uuid = uuid_factory.get_uuid_interface();

    std::string uuid_str = uuid->generate();

### Command Line Argument Parser

The CommandLineInterpreter makes working with input parameters easier.  With it,
we get access to command line arguments in the form:

`./example name=abc`

We have access to an opt_exist method to determine if an option was entered.  We can also use get_opt to pull parameter values, and get_program_name to return the current program name executing on this instance.

    #include "include/factory_cli.h"
    #include "include/factory/commandline_interface.h"

    int main( int argc, char** argv )
    {
    CommandLineInterpreterFactory cli_factory;
    CommandLineInterface *cli = cli_factory.get_command_line_interface( argc, argv );
    std::cout << cli->get_program_name() << std::endl;
    if ( cli->opt_exist("name") ) {
      std::cout << cli->get_opt("name") << std::endl;
    }

    return 0;
    }

## Tests
Please continue on to the [Tests] (https://github.com/AO-StreetArt/AOSharedServiceLibrary/tree/master/docs/tests) section of the documentation to learn about the libraries automated tests.

[Go Home] (https://github.com/AO-StreetArt/AOSharedServiceLibrary)
