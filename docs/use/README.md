# How to Use the AO Shared Service Library

The library is designed to be easy to use, and sample applications can be found in the examples folder.

This page is meant to be an overview of functionality, for complete documentation see the [full API documentation generated by Doxygen] (https://github.com/AO-StreetArt/AOSharedServiceLibrary/tree/master/docs/html).

## Service Component Factory

The Service Component Factory is a component which allows us to build instances of the interfaces exposed by the library.

It's important that we use the factory to get instances of the interfaces as the interfaces guarantee backwards-compatibility.  While particular implementations may change,
the interfaces will remain the same across versions of the library.

So, any application on the AO Shared Service Library begins with building this factory:

    // Set up a Service Component Factory, where we get our application components
    ServiceComponentFactory factory;

The factory then provides us access to instances of the interfaces exposed by the library.  Let's take a look with the components below.

Note: Be sure to delete anything you build with the factory!

## Couchbase Administrator

The Couchbase Administrator works with objects that extend the interface 'writeable.h', found in the include directory.

`class TestData: public Writeable`

We start by defining a class which extends the Writeable interface.  This requires only that we have three
methods implemented:

* get_key
* set_key
* to_json

Now, we can start building objects in our DB:

    //Create an object
    std::string name = "TestObject";
    TestData data ();
    data.set_key(name);
    const char* obj_key = data.get_key().c_str();

    //Build the Couchbase Admin (which will automatically connect to the DB),
    //by asking the factory to create the new instance
    CouchbaseInterface *cb = factory.get_couchbase_interface("couchbase://localhost/default");

    //Bind callbacks
    cb->bind_get_callback(get_callback);
    cb->bind_storage_callback(storage_callback);
    cb->bind_delete_callback(del_callback);

Please note that couchbase binds to callbacks for all operations.  Here we see a simple example:

    static void storage_callback(lcb_t instance, const void *cookie, lcb_storage_t op,
       lcb_error_t err, const lcb_store_resp_t *resp)
    {
      if (err == LCB_SUCCESS) {
        printf("Stored %.*s\n", (int)resp->v.v0.nkey, (char*)resp->v.v0.key);
      }
      else {
        fprintf(stderr, "Couldn't retrieve item: %s\n", lcb_strerror(instance, err));
      }
    }

    static void get_callback(lcb_t instance, const void *cookie, lcb_error_t err,
       const lcb_get_resp_t *resp)
    {
      printf("Retrieved key %.*s\n", (int)resp->v.v0.nkey, (char*)resp->v.v0.key);
      printf("Value is %.*s\n", (int)resp->v.v0.nbytes, (char*)resp->v.v0.bytes);
    }

    static void del_callback(lcb_t instance, const void *cookie, lcb_error_t err, const lcb_remove_resp_t *resp)
    {
      if (err == LCB_SUCCESS) {
        printf("Removed:");
        printf( (char*)resp->v.v0.key );
      }
      else {
        printf("Couldn't remove item:");
        printf(lcb_strerror(instance, err));
      }
    }

Once our callbacks are bound, we can start operating with Couchbase:

    //Write the object to the DB
    cb->create_object ( obj_ptr );
    cb->wait();
    //Get the object from the DB
    cb->load_object ( obj_key );
    cb->wait();
    //Update the object in the DB
    data.set_i ( 10 );
    cb->save_object ( obj_ptr );
    cb->wait();
    //Get the object from the DB to ensure it updates correctly
    cb->load_object ( obj_key );
    cb->wait();
    //Delete the object
    cb->delete_object ( obj_key );
    cb->wait();


## Redis Administrator

The Redis Admin allows for quick Redis access, and exposes the below methods to do so:

* std::string load ( const char * key )
* bool save ( const char * key, std::string msg )
* bool exists ( const char * key )
* bool del ( const char * key )
* bool expire ( const char * key, unsigned int second)

We can connect to a single Redis Instance or a cluster.

    //! Get a Redis Cluster Interface instance
    std::vector<RedisConnChain> RedisConnectionList;
    RedisConnChain r;
    r.ip = "127.0.0.1";
    r.port = 6379;
    r.password = "";
    r.pool_size = 2;
    r.timeout = 5;
    r.role = 0;
    RedisConnectionList.push_back(r);
    redis = factory.get_redis_cluster_interface( RedisConnectionList );

    //Now, we can access our basic Redis Operations
    bool bRet = redis->save("Test", "123");
    bool eRet = redis->exists("Test");
    std::string strValue = redis->load("Test");
    redis->del("Test");

## Consul Administrator

The Consul Admin is responsible for Service Registration & Discovery, Key-Value
Retrieval, and Health Check Configuration.

We first define a Service which represents the current instance of the code.

This contains an ID, a name, a connection, and a port number.  Tags can be added or not:

`ServiceInterface *s = factory.get_service_interface("1", "test", "http://localhost/", "5555");`

`s->add_tag("Testing");`

And build our Consul Admin, specifying the connection address:

`ConsulInterface *ca = factory.get_consul_interface("localhost:8500");`

Now, we can register the currently running instance of a service with Consul

`ca->register_service(*s);`

And, we can unregister on shutdown:

`ca->deregister_service(*s);`

We can get and set key-value storage elements:

`bool success = ca->set_config_value("Test", "123");`
`assert(success);`

`std::string test_val = ca->get_config_value("Test");`
`logging->debug(test_val);`

It also has some limited query capabilities, please see API for further details.

## HTTP Administrator

The HTTP Admin allows quick and easy HTTP Requests by exposing:

* bool put(char * url, char * data, int timeout)
* bool get(char * url, int timeout)
* bool post(char * url, char * data, int timeout)
* bool del(char * url, int timeout)

It also allows binding a callback to return when the data is recieved from a get request, by calling bind_get_callback(func)

    //------------------------------SETUP-------------------------------------//

    //A String to store response data
    std::string writedata;

    //This is the callback that gets called when we recieve the response to the
    //Get Curl Request
    size_t writeCallback(char * buf, size_t size, size_t nmemb, void* up)
    {

      logging->debug("Callback Triggered");

    //Put the response into a string
    for (int c = 0; c<size*nmemb; c++)
    {
      writedata.push_back(buf[c]);
    }

    return size*nmemb;
    }

    //Declare the admin
    HttpInterface *ha;

    //-------------------------------GET--------------------------------------//

    writedata.clear();

    ha->bind_get_callback(writeCallback);

    //Send the request
    bool success = ha->get(GETURL, 5);
    if (!success) {
    }
    else {
      logging->debug("Retrieved:");
      logging->debug(writedata);
    }

    //-------------------------------PUT--------------------------------------//
    success = ha->put(PUTURL, "123", 5);

    //-------------------------------POST-------------------------------------//
    success = ha->post(POSTURL, "CLYMAN", 5);

    //------------------------------DELETE------------------------------------//
    success = ha->del(DELETEURL, 5);

## Logging
Logging exposes a pointer to a Logger instance, which can log directly itself or
provide categories to log to.

    std::string initFileName = "configuration_file";
    logging = factory.get_logging_interface(initFileName);

    logging->debug("My message");
    logging->get_category("MyCategory").error("My other message");

We read from the [log4cpp configuration files] (http://log4cpp.sourceforge.net/api/classlog4cpp_1_1PropertyConfigurator.html), of which several examples are provided within the library itself.

## UUID Generation

Easy and quick Universally Unique ID Generation:

`uuidInterface uuid;`

`std::string uuid_str = uuid->generate();``

## ZeroMQ Sockets

This provides Request/Reply Managers for both Inbound and Outbound sockets.

The Zmqio object exposes these methods:

* recv() - a blocking call to wait for a message
* send(const char * msg, int msg_size)
* send(std::string msg)

In order to connect to a socket, we ask the factory to create one:

    //Set up the outbound ZMQ Client
    zmqo = factory.get_zmq_outbound_interface("tcp://localhost:5555");

    //Set up the inbound ZMQ Client
    zmqi = factory.get_zmq_inbound_interface("tcp://*:5555");

## Command Line Argument Parser

The CommandLineInterpreter makes working with input parameters easier.  With it,
we get access to command line arguments in the form:

`./example name=abc`

We have access to an opt_exist method to determine if an option was entered.  We can also use get_opt to pull parameter values, and get_program_name to return the current program name executing on this instance.

    int main( int argc, char** argv )
    {

    CommandLineInterface *cli = factory.get_command_line_interface( argc, argv );
    std::cout << cli->get_program_name() << std::endl;
    if ( cli->opt_exist("name") ) {
      std::cout << cli->get_opt("name") << std::endl;
    }

    return 0;
    }

## Tests
Please continue on to the [Tests] (https://github.com/AO-StreetArt/AOSharedServiceLibrary/tree/master/docs/tests) section of the documentation to learn about the libraries automated tests.

[Go Home] (https://github.com/AO-StreetArt/AOSharedServiceLibrary)
