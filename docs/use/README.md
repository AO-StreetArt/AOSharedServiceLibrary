# How to Use the AO Shared Service Library

This page is meant to be an overview of functionality, for complete documentation see the [full API documentation generated by Doxygen] (https://github.com/AO-StreetArt/AOSharedServiceLibrary/tree/master/docs/html).

## Core Components

### Service Component Factory

The Service Component Factory is a component which allows us to build instances of the interfaces exposed by the library.

It's important that we use the factory to get instances of the interfaces as the interfaces guarantee backwards-compatibility.  While particular implementations may change,
the interfaces will remain the same across versions of the library.

So, any application on the AO Shared Service Library begins with building this factory:

    // Set up a Service Component Factory, where we get our application components
    ServiceComponentFactory factory;

The factory then provides us access to instances of the interfaces exposed by the library.  Let's take a look with the components below.

Note: Be sure to delete anything you build with the factory!

### Callbacks

Request-based callbacks are critical components of AOSSL, and can be seen used with several AOSSL components.  All callbacks match the following method signature:
    std::string process_request(struct Request *req)

## Choose a Framework

### HTTP Server

The HTTP Server provides the architecture to expose a RESTful API for communication with your microservice.
This is the most common framework used for services in other languages.

The HTTP Server binds callbacks to URL's and allows for distinguishing between types of requests.

    //Set up the HTTP Server
    http = new HttpServer("0.0.0.0", 12345);
    http->bind_callback("/", process_request);
    http->bind_callback("/test", process_test_request);

Here, we bind the specified URL and port to a particular callback function, process_request().
Note that a string is returned from the method with the value being sent back to the client

    std::string process_request(struct Request *req)
    {
      std::string resp = "";
      if (req->req_err->err_code == NOERROR)
      {
        if (req->req_type == HTTP_GET)
        {
          resp = "Get Request";
          std::cout << resp << std::endl;
        }
        else if (req->req_type == HTTP_PUT)
        {
          resp = "Put Request";
          std::cout << resp << std::endl;
        }
        else if (req->req_type == HTTP_POST)
        {
          resp = "Post Request";
          std::cout << resp << std::endl;
          std::cout << req->req_data << std::endl;
        }
        else if (req->req_type == HTTP_DELETE)
        {
          resp = "Delete Request";
          std::cout << resp << std::endl;
        }
        else
        {
          resp = "Unknown Request Type";
          std::cout << resp << req->req_type << std::endl;
        }
      }
      return resp;
    }

And we distinguish between the types via the req_type pointer, as above.

### ZeroMQ Sockets

ZeroMQ is a permanent-connection alternative that provides high-speed, distributed messaging.

This provides Request/Reply Managers for both Inbound and Outbound sockets.

The Zmqio object exposes these methods:

* recv() - a blocking call to wait for a message
* send(const char * msg, int msg_size)
* send(std::string msg)

In order to connect to a socket, we ask the factory to create one:

    //Set up the outbound ZMQ Client
    zmqo = factory.get_zmq_outbound_interface("tcp://localhost:5555");

    //Set up the inbound ZMQ Client
    zmqi = factory.get_zmq_inbound_interface("tcp://*:5555");

## Tools

### Couchbase Administrator

Couchbase is a document-based database that allows for persistent, clusterable storage of data objects
for services.

The Couchbase Administrator works with objects that extend the interface 'writeable.h', found in the include directory.

`class TestData: public Writeable`

We start by defining a class which extends the Writeable interface.  This requires only that we have three
methods implemented:

* get_key
* set_key
* to_json

Now, we can start building objects in our DB:

    //Create an object
    std::string name = "TestObject";
    TestData data ();
    data.set_key(name);
    const char* obj_key = data.get_key().c_str();

    //Build the Couchbase Admin (which will automatically connect to the DB),
    //by asking the factory to create the new instance
    CouchbaseInterface *cb = factory.get_couchbase_interface("couchbase://localhost/default");

    //Bind callbacks
    cb->bind_get_callback(my_retrieval_callback);
    cb->bind_storage_callback(my_storage_callback);
    cb->bind_delete_callback(my_delete_callback);

Please note that couchbase binds to callbacks for all operations.  Here we see a simple example of the request callbacks:

    std::string my_storage_callback (Request *r)
    {
      if (r->req_err->err_code == NOERROR)
      {
        std::cout << "stored: " << r->req_addr << std::endl;
      }
      else
      {
        std::cout << "Failed to Store: " << r->req_addr << std::endl;
        std::cout << r->req_err->err_message << std::endl;
      }
      return r->req_addr;
    }

    std::string my_retrieval_callback (Request *r)
    {
      if (r->req_err->err_code == NOERROR)
      {
        std::cout << "retrieved: " << r->req_addr << std::endl;
        std::cout << "value: " << r->req_data << std::endl;
      }
      else
      {
        std::cout << "Failed to Store: " << r->req_addr << std::endl;
        std::cout << r->req_err->err_message << std::endl;
      }
      return r->req_addr;
    }

    std::string my_delete_callback (Request *r)
    {
      if (r->req_err->err_code == NOERROR)
      {
        std::cout << "removed: " << r->req_addr << std::endl;
      }
      else
      {
        std::cout << "Failed to Delete: " << r->req_addr << std::endl;
        std::cout << r->req_err->err_message << std::endl;
      }
      return r->req_addr;
    }


Once our callbacks are bound, we can start operating with Couchbase:

    //Write the object to the DB
    cb->create_object ( obj_ptr );
    cb->wait();
    //Get the object from the DB
    cb->load_object ( obj_key );
    cb->wait();
    //Update the object in the DB
    data.set_i ( 10 );
    cb->save_object ( obj_ptr );
    cb->wait();
    //Get the object from the DB to ensure it updates correctly
    cb->load_object ( obj_key );
    cb->wait();
    //Delete the object
    cb->delete_object ( obj_key );
    cb->wait();


### Redis Administrator

Redis is a key-value store that acts as an application cache

The Redis Admin allows for quick Redis access, and exposes the below methods to do so:

* std::string load ( const char * key )
* bool save ( const char * key, std::string msg )
* bool exists ( const char * key )
* bool del ( const char * key )
* bool expire ( const char * key, unsigned int second)

We can connect to a single Redis Instance or a cluster.

    //! Get a Redis Cluster Interface instance
    std::vector<RedisConnChain> RedisConnectionList;
    RedisConnChain r;
    r.ip = "127.0.0.1";
    r.port = 6379;
    r.password = "";
    r.pool_size = 2;
    r.timeout = 5;
    r.role = 0;
    RedisConnectionList.push_back(r);
    redis = factory.get_redis_cluster_interface( RedisConnectionList );

    //Now, we can access our basic Redis Operations
    bool bRet = redis->save("Test", "123");
    bool eRet = redis->exists("Test");
    std::string strValue = redis->load("Test");
    redis->del("Test");

### Consul Administrator

Consul is responsible for Service Registration & Discovery, Key-Value
Retrieval, and Health Check Configuration.

We first define a Service which represents the current instance of the code.

This contains an ID, a name, a connection, and a port number.  Tags can be added or not:

`ServiceInterface *s = factory.get_service_interface("1", "test", "http://localhost/", "5555");`

`s->add_tag("Testing");`

And build our Consul Admin, specifying the connection address:

`ConsulInterface *ca = factory.get_consul_interface("localhost:8500");`

Now, we can register the currently running instance of a service with Consul

`ca->register_service(*s);`

And, we can unregister on shutdown:

`ca->deregister_service(*s);`

We can get and set key-value storage elements:

`bool success = ca->set_config_value("Test", "123");`
`assert(success);`

`std::string test_val = ca->get_config_value("Test");`
`logging->debug(test_val);`

It also has some limited query capabilities, please see API for further details.

### HTTP Administrator

The HTTP Admin allows quick and easy HTTP Requests by exposing:

* bool put(char * url, char * data, int timeout)
* bool get(char * url, int timeout)
* bool post(char * url, char * data, int timeout)
* bool del(char * url, int timeout)

It also allows binding a callback to return when the data is recieved from a get request, by calling bind_get_callback(func)

    //------------------------------SETUP-------------------------------------//

    //A String to store response data
    std::string writedata;

    //This is the callback that gets called when we recieve the response to the
    //Get Curl Request
    size_t writeCallback(char * buf, size_t size, size_t nmemb, void* up)
    {

      logging->debug("Callback Triggered");

    //Put the response into a string
    for (int c = 0; c<size*nmemb; c++)
    {
      writedata.push_back(buf[c]);
    }

    return size*nmemb;
    }

    //Declare the admin
    HttpInterface *ha;

    //-------------------------------GET--------------------------------------//

    writedata.clear();

    ha->bind_get_callback(writeCallback);

    //Send the request
    bool success = ha->get(GETURL, 5);
    if (!success) {
    }
    else {
      logging->debug("Retrieved:");
      logging->debug(writedata);
    }

    //-------------------------------PUT--------------------------------------//
    success = ha->put(PUTURL, "123", 5);

    //-------------------------------POST-------------------------------------//
    success = ha->post(POSTURL, "CLYMAN", 5);

    //------------------------------DELETE------------------------------------//
    success = ha->del(DELETEURL, 5);

### Logging
Logging exposes a pointer to a Logger instance, which can log directly itself or
provide categories to log to.

    std::string initFileName = "configuration_file";
    logging = factory.get_logging_interface(initFileName);

    logging->debug("My message");
    logging->get_category("MyCategory").error("My other message");

We read from the [log4cpp configuration files] (http://log4cpp.sourceforge.net/api/classlog4cpp_1_1PropertyConfigurator.html), of which several examples are provided within the library itself.

### UUID Generation

Easy and quick Universally Unique ID Generation:

`uuidInterface uuid;`

`std::string uuid_str = uuid->generate();``

### Command Line Argument Parser

The CommandLineInterpreter makes working with input parameters easier.  With it,
we get access to command line arguments in the form:

`./example name=abc`

We have access to an opt_exist method to determine if an option was entered.  We can also use get_opt to pull parameter values, and get_program_name to return the current program name executing on this instance.

    int main( int argc, char** argv )
    {

    CommandLineInterface *cli = factory.get_command_line_interface( argc, argv );
    std::cout << cli->get_program_name() << std::endl;
    if ( cli->opt_exist("name") ) {
      std::cout << cli->get_opt("name") << std::endl;
    }

    return 0;
    }

## Tests
Please continue on to the [Tests] (https://github.com/AO-StreetArt/AOSharedServiceLibrary/tree/master/docs/tests) section of the documentation to learn about the libraries automated tests.

[Go Home] (https://github.com/AO-StreetArt/AOSharedServiceLibrary)
