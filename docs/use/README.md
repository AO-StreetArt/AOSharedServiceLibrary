# How to Use the AO Shared Service Library

The library is designed to be easy to use, and examples can be found in the test file for each object.

This page is meant to be an overview of functionality, for complete documentation see the [full API documentation generated by Doxygen] (https://github.com/AO-StreetArt/AOSharedServiceLibrary/tree/master/docs/html).

## Couchbase Administrator

The Couchbase Administrator works with objects that extend the interface 'writeable.h', found in the include directory.

Let's look at the couchbase_test.cpp file.

`class TestData: public Writeable`

We start by defining a class which extends the Writeable interface.  This requires only that we have three
methods implemented:

* get_key
* set_key
* to_json

Now, we can start building objects in our DB:

    //Create an object
    std::string name = "TestObject";
    TestData data ();
    data.set_key(name);
    const char* obj_key = data.get_key().c_str();

    //Build the Couchbase Admin (which will automatically connect to the DB)
    CouchbaseAdmin cb ("couchbase://localhost/default");

    //Bind callbacks
    cb.bind_get_callback(get_callback);
    cb.bind_storage_callback(storage_callback);
    cb.bind_delete_callback(del_callback);

Please note that couchbase binds to callbacks for all operations.  Here we see a simple example:

    static void storage_callback(lcb_t instance, const void *cookie, lcb_storage_t op,
       lcb_error_t err, const lcb_store_resp_t *resp)
    {
      if (err == LCB_SUCCESS) {
        printf("Stored %.*s\n", (int)resp->v.v0.nkey, (char*)resp->v.v0.key);
      }
      else {
        fprintf(stderr, "Couldn't retrieve item: %s\n", lcb_strerror(instance, err));
      }
    }

    static void get_callback(lcb_t instance, const void *cookie, lcb_error_t err,
       const lcb_get_resp_t *resp)
    {
      printf("Retrieved key %.*s\n", (int)resp->v.v0.nkey, (char*)resp->v.v0.key);
      printf("Value is %.*s\n", (int)resp->v.v0.nbytes, (char*)resp->v.v0.bytes);
    }

    static void del_callback(lcb_t instance, const void *cookie, lcb_error_t err, const lcb_remove_resp_t *resp)
    {
      if (err == LCB_SUCCESS) {
        printf("Removed:");
        printf( (char*)resp->v.v0.key );
      }
      else {
        printf("Couldn't remove item:");
        printf(lcb_strerror(instance, err));
      }
    }

Once our callbacks are bound, we can start operating with Couchbase:

    //Write the object to the DB
    cb.create_object ( obj_ptr );
    cb.wait();
    //Get the object from the DB
    cb.load_object ( obj_key );
    cb.wait();
    //Update the object in the DB
    data.set_i ( 10 );
    cb.save_object ( obj_ptr );
    cb.wait();
    //Get the object from the DB to ensure it updates correctly
    cb.load_object ( obj_key );
    cb.wait();
    //Delete the object
    cb.delete_object ( obj_key );
    cb.wait();


## Redis Administrator

The Redis Admin allows for quick Redis access, and exposes the below methods to do so:

* std::string load ( const char * key )
* bool save ( const char * key, std::string msg )
* bool exists ( const char * key )
* bool del ( const char * key )
* bool expire ( const char * key, unsigned int second)

We can connect to a single Redis Instance or a cluster.

    //Set up The Redis Connection, whether single or clustered
    RedisNode redis_list[1];

    RedisNode redis_n;
    redis_n.dbindex = 1;
    redis_n.host = "127.0.0.1";
    redis_n.port = 7000;
    redis_n.passwd = "password";
    redis_n.poolsize = 2;
    redis_n.timeout = 5;
    redis_n.role = 0;

    redis_list[0] = redis_n;

    //Connect to Redis
    xRedis = new xRedisAdmin (redis_list, 1);

    //Now, we can access our basic Redis Operations
    bool bRet = xRedis->save("Test", "123");
    bool eRet = xRedis->exists("Test");
    std::string strValue = xRedis->load("Test");
    xRedis->del("Test");

## Consul Administrator

The Consul Admin is responsible for Service Registration & Discovery, Key-Value
Retrieval, and Health Check Configuration.

We first define a Service which represents the current instance of the code.

This contains an ID, a name, a connection, and a port number.  Tags can be added or not:

`Service s ("1", "test", "http://localhost/", "5555");`
`s.add_tag("Testing");`

And build our Consul Admin, specifying the connection address:

`ConsulAdmin ca ("localhost:8500");`

Now, we can register the currently running instance of a service with Consul

`ca.register_service(s);`

And, we can unregister on shutdown:

`ca.deregister_service(s);`

We can get and set key-value storage elements:

`bool success = ca.set_config_value("Test", "123");`
`assert(success);`

`std::string test_val = ca.get_config_value("Test");`
`logging->debug(test_val);`

It also has some limited query capabilities, please see API for further details.

## HTTP Administrator

The HTTP Admin allows quick and easy HTTP Requests by exposing:

* bool put(char * url, char * data, int timeout)
* bool get(char * url, int timeout)
* bool post(char * url, char * data, int timeout)
* bool del(char * url, int timeout)

It also allows binding a callback to return when the data is recieved from a get request, by calling bind_get_callback(func)

    //------------------------------SETUP-------------------------------------//

    //A String to store response data
    std::string writedata;

    //This is the callback that gets called when we recieve the response to the
    //Get Curl Request
    size_t writeCallback(char * buf, size_t size, size_t nmemb, void* up)
    {

      logging->debug("Callback Triggered");

    //Put the response into a string
    for (int c = 0; c<size*nmemb; c++)
    {
      writedata.push_back(buf[c]);
    }

    return size*nmemb;
    }

    //Declare the admin
    HttpAdmin ha;

    //-------------------------------GET--------------------------------------//

    writedata.clear();

    ha.bind_get_callback(writeCallback);

    //Send the request
    bool success = ha.get(GETURL, 5);
    if (!success) {
    }
    else {
      logging->debug("Retrieved:");
      logging->debug(writedata);
    }

    //-------------------------------PUT--------------------------------------//
    success = ha.put(PUTURL, "123", 5);

    //-------------------------------POST-------------------------------------//
    success = ha.post(POSTURL, "CLYMAN", 5);

    //------------------------------DELETE------------------------------------//
    success = ha.del(DELETEURL, 5);

## Logging
Logging exposes a pointer to a Logger instance, which can log directly itself or
provide categories to log to.

    std::string initFileName = "configuration_file";
    logging = new Logger(initFileName);

    logging->debug("My message");
    logging->get_category("MyCategory").error("My other message");

We read from the [log4cpp configuration files] (http://log4cpp.sourceforge.net/api/classlog4cpp_1_1PropertyConfigurator.html), of which several examples are provided within the library itself.

## UUID Generation

Easy and quick Universally Unique ID Generation:

`uuidAdmin uuid;`

`std::string uuid_str = uuid.generate();``

## ZeroMQ Sockets

This provides Request/Reply Managers for both Inbound and Outbound sockets.

Both the Zmqo and Zmqi objects expose these methods:

* recv() - a blocking call to wait for a message
* send(const char * msg, int msg_size)
* send(std::string msg)

In order to connect to a socket, Zmqo exposes connect while Zmqi exposes bind:

    //We maintain the ZMQ Context and pass it to the ZMQ objects coming from aossl
    zmq::context_t context(1, 2);

    //Set up the outbound ZMQ Client
    zmqo = new Zmqo (context);
    zmqo->connect("tcp://localhost:5555");

    //Set up the inbound ZMQ Client
    zmqi = new Zmqi (context);
    zmqi->bind("tcp://*:5555");

## Command Line Argument Parser

The CommandLineInterpreter makes working with input parameters easier.  With it,
we get access to command line arguments in the form:

`./example -name=abc`

We have access to an opt_exist method to determine if an option was entered.  We can also use get_opt to pull parameter values, and get_program_name to return the current program name executing on this instance.

    int main( int argc, char** argv )
    {

    CommandLineInterpreter cli ( argc, argv );
    std::cout << cli.get_program_name() << std::endl;
    if ( cli.opt_exist("name") ) {
      std::cout << cli.get_opt("name") << std::endl;
    }

    return 0;
    }

## Tests
Please continue on to the [Tests] (https://github.com/AO-StreetArt/AOSharedServiceLibrary/tree/master/docs/tests) section of the documentation to learn about the libraries automated tests.

[Go Home] (https://github.com/AO-StreetArt/AOSharedServiceLibrary)
