The H\+T\+TP Server provides the architecture to expose a R\+E\+S\+Tful A\+PI for communication with your microservice. This is the most common framework used for services in other languages.

This is N\+OT intended for use as a public web server. It has no built-\/in templating mechanisms, or security features. It is an absolute bare-\/bones implementation of an H\+T\+TP server.

\subsection*{Use}

The H\+T\+TP Server binds callbacks to U\+RL\textquotesingle{}s and allows for distinguishing between types of requests. \begin{DoxyVerb}#include "aossl/http/server/factory_http_server.h"
#include "aossl/http/server/http_server_interface.h"

//Set up the HTTP Server
HttpServerFactory http_server_factory;
HttpServerInterface *http = http_server_factory.get_http_server_interface("0.0.0.0", 12345);
\end{DoxyVerb}


Bind some callbacks against specific U\+R\+Ls \begin{DoxyVerb}http->bind_callback("/", process_request);
http->bind_callback("/test", process_test_request);
\end{DoxyVerb}


Bind a default callback, which is called when a bound callback is not found for the request U\+RL. Useful for A\+PI\textquotesingle{}s that rely on dynamic U\+RL construction for querying \begin{DoxyVerb}http->bind_default_callback(process_default_request);
\end{DoxyVerb}


Here, we bind the specified U\+RL and port to a particular callback function, process\+\_\+request(). Note that a string is returned from the method with the value being sent back to the client \begin{DoxyVerb}std::string process_request(struct Request *req)
{
  std::string resp = "";
  if (req->req_err->err_code == NOERROR)
  {
    if (req->req_type == HTTP_GET)
    {
      resp = "Get Request";
      std::cout << resp << std::endl;
    }
    else if (req->req_type == HTTP_PUT)
    {
      resp = "Put Request";
      std::cout << resp << std::endl;
    }
    else if (req->req_type == HTTP_POST)
    {
      resp = "Post Request";
      std::cout << resp << std::endl;
      std::cout << req->req_data << std::endl;
    }
    else if (req->req_type == HTTP_DELETE)
    {
      resp = "Delete Request";
      std::cout << resp << std::endl;
    }
    else
    {
      resp = "Unknown Request Type";
      std::cout << resp << req->req_type << std::endl;
    }
  }
  return resp;
}
\end{DoxyVerb}


And we distinguish between the types via the req\+\_\+type pointer, as above.

We can also bind a default callback, which get\textquotesingle{}s called whenever a bound U\+RI is not found. This can be particular useful for allowing access to things like key-\/value stores

\subsection*{Callbacks}

All callbacks match the following method signature\+: std\+::string process\+\_\+request(struct Request $\ast$req)

The Request object has a few properties which are relevant\+:


\begin{DoxyItemize}
\item req\+\_\+data -\/ Used to store original request data
\item req\+\_\+addr -\/ Used to store the request type
\item req\+\_\+err -\/ A pointer used to store any error messages from the request
\item resp\+\_\+data -\/ Used to store response data from the request
\end{DoxyItemize}

The Request Error, if present, will come in the form of\+: \begin{DoxyVerb}//! A struct that gets passed to callbacks to transmit errors
struct RequestError
{
  //! A numerical error code
  int err_code;

  //! An Error message
  std::string err_message;
  RequestError() {err_code = NOERROR; err_message = "";}
};
\end{DoxyVerb}


\hyperlink{index}{Go Home} 